# ==============================================================================
# TEMPLATE DE DÉPLOIEMENT MICROSERVICE (STATEFUL)
# ==============================================================================
# VARIABLES À REMPLACER :
#   {{SERVICE_NAME}} : Nom du service (ex: auth-service, user-service)
#   {{SERVICE_PORT}} : Port exposé par le Service K8s (ex: 3001, 3002)
# ==============================================================================

apiVersion: v1
kind: Service
metadata:
  name: {{SERVICE_NAME}}
  labels:
    app: {{SERVICE_NAME}}
spec:
  # Service ClusterIP standard pour la communication interne
  type: ClusterIP
  ports:
    - port: {{SERVICE_PORT}}
      targetPort: 3000 # Port interne fixe du conteneur (défini dans le template Fastify)
      name: http
  selector:
    app: {{SERVICE_NAME}}

---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: {{SERVICE_NAME}}
spec:
  serviceName: {{SERVICE_NAME}}
  # CONSTRAINT : SQLite ne supporte qu'un seul écrivain à la fois.
  # On force 1 réplica pour éviter la corruption de données.
  replicas: 1
  
  selector:
    matchLabels:
      app: {{SERVICE_NAME}}
      
  template:
    metadata:
      labels:
        app: {{SERVICE_NAME}}
      annotations:
        # ======================================================================
        # CONFIGURATION VAULT AGENT (SIDECAR)
        # ======================================================================
        vault.hashicorp.com/agent-inject: "true"
        # Le rôle doit être créé via le script 02_create_roles.sh
        vault.hashicorp.com/role: "{{SERVICE_NAME}}-role"
        
        # Secret spécifique au service (ex: secret/data/app/auth-service)
        vault.hashicorp.com/agent-inject-secret-config: "secret/data/app/{{SERVICE_NAME}}"
        
        # Template d'injection :
        # 1. Définit les variables standards (DB, Port, Nom)
        # 2. Itère sur toutes les clés du secret Vault pour les exporter en ENV
        vault.hashicorp.com/agent-inject-template-config: |
          {{- with secret "secret/data/app/{{SERVICE_NAME}}" -}}
            export DB_PATH="/data/{{SERVICE_NAME}}.db"
            export API_PORT="3000"
            export SERVICE_NAME="{{SERVICE_NAME}}"
            {{- range $k, $v := .Data.data }}
            export {{ $k | toupper }}={{ $v | toJSON }}
            {{- end }}
          {{- end -}}

    spec:
      # Le ServiceAccount doit être créé dans base/service-accounts.yaml
      serviceAccountName: {{SERVICE_NAME}}
      
      # SÉCURITÉ : Exécution en tant qu'utilisateur non-root (node:1000)
      securityContext:
        runAsUser: 1000
        runAsGroup: 1000
        fsGroup: 1000

      # INIT CONTAINER : Correction des permissions du volume
      # Les volumes (PVC) sont souvent montés appartenant à root.
      # Ce conteneur éphémère rend le dossier /data accessible à l'utilisateur node.
      initContainers:
        - name: fix-permissions
          image: busybox:1.36
          command: ["sh", "-c", "chown -R 1000:1000 /data && chmod 700 /data"]
          securityContext:
            runAsUser: 0 # Nécessaire pour chown
          volumeMounts:
            - name: data-volume
              mountPath: /data

      containers:
        - name: {{SERVICE_NAME}}
          image: {{SERVICE_NAME}}:latest
          imagePullPolicy: Never # Utilise l'image locale du registry K3s
          
          ports:
            - containerPort: 3000
              name: http

          # DÉMARRAGE SÉCURISÉ :
          # On "source" le fichier de secrets généré par Vault avant de lancer l'app.
          # Les secrets résident uniquement en mémoire du processus.
          command: ["/bin/sh", "-c"]
          args: [". /vault/secrets/config && node apps/{{SERVICE_NAME}}/dist/main.js"]
          
          # RESSOURCES :
          # Définition des limites pour éviter qu'un service ne sature le nœud.
          resources:
            requests:
              memory: "128Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "500m"

          # PROBES (OBSERVABILITÉ) :
          # Utilisent notre route /api/health qui vérifie la connectivité SQLite.
          livenessProbe:
            httpGet:
              path: /api/health
              port: 3000
            initialDelaySeconds: 10 # Laisse le temps au serveur de démarrer
            periodSeconds: 15
            failureThreshold: 3
          
          readinessProbe:
            httpGet:
              path: /api/health
              port: 3000
            initialDelaySeconds: 5
            periodSeconds: 5
            successThreshold: 1

          volumeMounts:
            - name: data-volume
              mountPath: /data

  # PERSISTANCE DES DONNÉES (PVC)
  # Crée automatiquement un volume dédié pour ce service.
  volumeClaimTemplates:
    - metadata:
        name: data-volume
      spec:
        accessModes: [ "ReadWriteOnce" ]
        storageClassName: "local-path" # Classe de stockage standard K3s
        resources:
          requests:
            storage: 1Gi